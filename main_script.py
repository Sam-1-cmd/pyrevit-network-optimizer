# -*- coding: utf-8 -*-
"""main_script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15JsFF06U4JIKKkQQ9Ux11xAnOAlsL2SA
"""

# -*- coding: utf-8 -*-
"""
PyRevit – Génération intelligente de conduits
===========================================
Script développé dans le cadre d'un projet de recherche à l'ESTP Paris.

Fonction principale :
    Tracer automatiquement une gaine 3D entre deux éléments MEP sélectionnés
    dans un modèle Revit, en évitant les obstacles (murs, poutres, etc.) et en
    enregistrant éventuellement le trajet pour ré‑utilisation.

>>> Étapes clés
1. Sélection des deux éléments (départ / arrivée) et de l'obstacle à contourner
2. Calcul des centres et distances
3. Détection de collision avec le mur
4. Génération de points intermédiaires si nécessaire
5. Création de conduits (DirectShape) entre chaque point
6. Sauvegarde facultative du trajet dans un fichier JSON "mémoire"

NB : Le code est commenté pour faciliter la lecture et l'adaptation.
"""

# === IMPORTS & API BINDINGS ===
import clr
import math
import json
import os

# -- Références Revit API
clr.AddReference("RevitAPI")
clr.AddReference("RevitAPIUI")

from Autodesk.Revit.DB import *  # noqa: F403, E402
from Autodesk.Revit.UI import *  # noqa: F403, E402
from Autodesk.Revit.UI.Selection import ObjectType  # noqa: E402
from Autodesk.Revit.Exceptions import OperationCanceledException  # noqa: E402

# -- Objets Revit utiles (uidoc / doc / app)
uidoc = revit.ActiveUIDocument  # type: ignore  # fourni par pyRevit
doc   = uidoc.Document
app   = revit.Application        # type: ignore

# Tolérance Revit pour les comparaisons géométriques
TOLERANCE = doc.Application.ShortCurveTolerance

# === CHEMIN DU FICHIER MÉMOIRE =============================================
# → Modifier ce chemin si besoin. Le fichier stocke les trajets déjà validés
#   afin d'éviter de recalculer un itinéraire identique.
MEMORY_FILE = os.path.expanduser(r"~\\AppData\\Roaming\\pyRevit\\memory_paths.json")

# ===========================================================================
# FONCTIONS UTILITAIRES
# ===========================================================================

def get_element_center(element):
    """Retourne le centre (XYZ) d'un élément Revit via son bounding box."""
    bbox = element.get_BoundingBox(None)
    return (bbox.Min + bbox.Max) / 2


def create_cylinder(start_pt, end_pt, radius, material_name=""):
    """Crée un cylindre (DirectShape) entre `start_pt` et `end_pt`.

    Args:
        start_pt (XYZ): point de départ
        end_pt (XYZ): point d'arrivée
        radius (float): rayon de la gaine (en unités Revit)
        material_name (str): nom du matériau (optionnel)
    Returns:
        DirectShape: l'élément créé dans le modèle
    """
    direction      = end_pt - start_pt
    height         = direction.GetLength()
    z_axis         = direction.Normalize()

    # -- Profil circulaire discretisé tous les 10° (36 segments)
    profile = []
    for angle_deg in range(0, 360, 10):
        angle_rad = math.radians(angle_deg)
        profile.append(XYZ(radius * math.cos(angle_rad),
                           radius * math.sin(angle_rad), 0))
    profile.append(profile[0])  # on ferme le cercle

    # -- Transformation locale pour orienter le cylindre dans l'espace
    # Choix d'un X perpendiculaire à Z sans être colinéaire
    x_axis = XYZ.BasisX if abs(z_axis.DotProduct(XYZ.BasisX)) < 0.8 else XYZ.BasisY
    y_axis = z_axis.CrossProduct(x_axis).Normalize()
    x_axis = y_axis.CrossProduct(z_axis).Normalize()

    transform = Transform.Identity
    transform.Origin  = start_pt
    transform.BasisX  = x_axis
    transform.BasisY  = y_axis
    transform.BasisZ  = z_axis

    # -- Création du CurveLoop transformé
    loop = CurveLoop()
    for i in range(len(profile) - 1):
        loop.Append(Line.CreateBound(profile[i], profile[i + 1]))
    transformed_loop = CurveLoop.CreateViaTransform(loop, transform)

    # -- Solide extrudé
    solid = GeometryCreationUtilities.CreateExtrusionGeometry([transformed_loop],
                                                              z_axis, height)

    # -- DirectShape
    category    = ElementId(BuiltInCategory.OST_GenericModel)
    ds_type_name = "Gaine_3D" + ("_" + material_name if material_name else "")
    ds_type      = DirectShapeType.Create(doc, ds_type_name, category)

    # -- Application matériau (si trouvé)
    if material_name:
        materials = FilteredElementCollector(doc).OfClass(Material)
        material  = next((m for m in materials if m.Name == material_name), None)
        if material:
            if hasattr(ds_type, "SetMaterialId"):
                ds_type.SetMaterialId(material.Id)
            else:
                ds_type.MaterialId = material.Id  # fallback ancienne API

    ds = DirectShape.CreateElement(doc, category)
    ds.SetTypeId(ds_type.Id)
    ds.SetShape([solid])

    # -- Paramètre commentaire
    if (param := ds.LookupParameter("Comments")):
        param.Set("Gaine entre éléments")

    return ds


def get_element_info(element):
    """Retourne un tuple d'informations textuelles sur l'élément."""
    name         = element.Name
    element_type = element.GetType().ToString().split(".")[-1]
    family_name  = element.Symbol.Family.Name if hasattr(element, "Symbol") else "N/A"
    element_id   = element.Id.IntegerValue
    return name, element_type, family_name, element_id


# ===========================================================================
# SÉLECTION DES ÉLÉMENTS & MUR OBSTACLE
# ===========================================================================
try:
    # Message introductif
    TaskDialog.Show("Sélection", (
        "Vous allez sélectionner successivement :\n"
        "1. L'élément de départ\n2. L'élément d'arrivée\n3. Le mur (obstacle)"))

    # --- Élément de départ ---
    TaskDialog.Show("Sélection", "Veuillez sélectionner l'élément de départ")
    ref1          = uidoc.Selection.PickObject(ObjectType.Element,
                                              "Sélectionnez l'élément de départ")
    element1      = doc.GetElement(ref1)
    point_depart  = get_element_center(element1)

    # Infos texte
    info_depart = "Nom: {}\nType: {}\nFamille: {}\nID: {}".format(*get_element_info(element1))

    # --- Élément d'arrivée ---
    TaskDialog.Show("Sélection", "Veuillez sélectionner l'élément d'arrivée")
    ref2          = uidoc.Selection.PickObject(ObjectType.Element,
                                              "Sélectionnez l'élément d'arrivée")
    element2      = doc.GetElement(ref2)
    point_arrivee = get_element_center(element2)
    info_arrivee  = "Nom: {}\nType: {}\nFamille: {}\nID: {}".format(*get_element_info(element2))

    # --- Mur obstacle ---
    TaskDialog.Show("Sélection", "Veuillez sélectionner l'obstacle (mur / poutre)")
    wall_ref = uidoc.Selection.PickObject(ObjectType.Element,
                                          "Sélectionnez le mur")
    wall      = doc.GetElement(wall_ref)
    wall_type = doc.GetElement(wall.GetTypeId())

    # Récupération dimensions du mur (hauteur, longueur, épaisseur)
    dimensions = []
    height_param = wall.get_Parameter(BuiltInParameter.WALL_USER_HEIGHT_PARAM)
    height       = height_param.AsDouble() * 304.8 if height_param else 0
    dimensions.append(height)

    length = wall.Location.Curve.Length * 304.8 if wall.Location and hasattr(wall.Location, "Curve") else 0
    dimensions.append(length)

    width_param = wall_type.get_Parameter(BuiltInParameter.WALL_ATTR_WIDTH_PARAM)
    width       = width_param.AsDouble() * 304.8 if width_param else 0
    dimensions.append(width)

    hauteur_mur, longueur_mur, epaisseur_mur = dimensions

except OperationCanceledException:
    TaskDialog.Show("Info", "Opération annulée par l'utilisateur.")
    raise

# ===========================================================================
# GÉOMÉTRIE & DÉTECTION DE COLLISION
# ===========================================================================
# Points de départ (D) et arrivée (F)
xd, yd, zd = point_depart.X, point_depart.Y, point_depart.Z
xf, yf, zf = point_arrivee.X, point_arrivee.Y, point_arrivee.Z


def calculate_distance(p1, p2):
    """Distance euclidienne entre deux XYZ."""
    return math.sqrt((p2.X - p1.X) ** 2 + (p2.Y - p1.Y) ** 2 + (p2.Z - p1.Z) ** 2)


a = calculate_distance(point_depart, get_element_center(wall))
b = calculate_distance(point_arrivee, get_element_center(wall))


def is_line_touching_wall(start_pt, end_pt, wall_elem):
    """Retourne True si la ligne start‑end intersecte le mur."""
    line    = Line.CreateBound(start_pt, end_pt)
    options = Options()
    options.ComputeReferences        = True
    options.IncludeNonVisibleObjects = False

    for geom_obj in wall_elem.get_Geometry(options):
        if isinstance(geom_obj, Solid):
            for face in geom_obj.Faces:
                projection = face.Project(start_pt)
                if projection and projection.Distance < TOLERANCE:
                    return True
    return False


def generate_points_intermediaires(wall_elem, max_attempts=10, step=0.01):
    """Génère deux points intermédiaires (A, B) pour contourner le mur."""
    attempts = 0
    offset   = step
    while attempts < max_attempts:
        pointB = XYZ(xf - b + offset, yd + a + offset, zd + offset)
        pointA = XYZ(xf - b + offset, yf - b + offset, zd + offset)

        if not (is_line_touching_wall(pointA, pointB, wall_elem) or
                is_line_touching_wall(pointB, point_arrivee, wall_elem)):
            return pointA, pointB

        offset += step
        attempts += 1
    return pointA, pointB  # retourné même si toujours collision (fallback)


pointA, pointB = generate_points_intermediaires(wall)

# Longueur totale (m)
longueur_tuyau = (calculate_distance(point_depart, pointA) +
                   calculate_distance(pointA, pointB) +
                   calculate_distance(pointB, point_arrivee))

# ===========================================================================
# CRÉATION DES CONDUITS (TRANSACTION)
# ===========================================================================
with Transaction(doc, "Tracer gaine avec contournement") as tr:
    tr.Start()

    radius        = 0.05  # 0.10 m / 2 → rayon 5 cm (adapter si besoin)
    material_name = "PVC"

    create_cylinder(point_depart, pointA, radius, material_name)
    create_cylinder(pointA,       pointB, radius, material_name)
    create_cylinder(pointB, point_arrivee, radius, material_name)

    tr.Commit()

# ===========================================================================
# AFFICHAGE RÉCAPITULATIF POUR L'UTILISATEUR
# ===========================================================================
resume = (
    "Coordonnées du point de départ (D) : X={0:.2f} Y={1:.2f} Z={2:.2f}\n"
    "Coordonnées du point d'arrivée (F) : X={3:.2f} Y={4:.2f} Z={5:.2f}\n"
    "Coordonnées du point intermédiaire A : X={6:.2f} Y={7:.2f} Z={8:.2f}\n"
    "Coordonnées du point intermédiaire B : X={9:.2f} Y={10:.2f} Z={11:.2f}\n"
    "Longueur totale du tuyau : {12:.2f} m"
).format(xd, yd, zd, xf, yf, zf,
         pointA.X, pointA.Y, pointA.Z,
         pointB.X, pointB.Y, pointB.Z,
         longueur_tuyau)
TaskDialog.Show("Résumé du trajet", resume)

# ===========================================================================
# MÉMOIRE (IA SIMPLE) POUR RÉUTILISER LES TRAJETS
# ===========================================================================

def load_memory(file_path):
    if not os.path.exists(file_path):
        return []
    with open(file_path, "r") as f:
        return json.load(f)


def save_to_memory(file_path, new_entry):
    data = load_memory(file_path)
    data.append(new_entry)
    with open(file_path, "w") as f:
        json.dump(data, f, indent=4)


def points_match(val1, val2, tolerance=300):
    """Compare deux valeurs (pieds) avec tolérance : 300 mm ≈ 0.984 ft."""
    return abs(val1 - val2) < (tolerance / 304.8)


def search_existing_path(memory, d_depart, d_arrivee, dims_mur):
    """Recherche si un trajet équivalent existe déjà dans la mémoire."""
    for entry in memory:
        if (points_match(entry["d_depart_mur"], d_depart) and
                points_match(entry["d_mur_arrivee"], d_arrivee)) or \
           points_match(entry["mur_dimensions"]["hauteur"],  dims_mur["hauteur"]) or \
           points_match(entry["mur_dimensions"]["epaisseur"], dims_mur["epaisseur"]):
            return [XYZ(*pt) for pt in entry["path"]]
    return None


dims_mur = {"hauteur": hauteur_mur, "epaisseur": epaisseur_mur}

d_depart  = calculate_distance(point_depart,  get_element_center(wall))
d_arrivee = calculate_distance(point_arrivee, get_element_center(wall))

memory            = load_memory(MEMORY_FILE)
intermediate_pts  = search_existing_path(memory, d_depart, d_arrivee, dims_mur)
if intermediate_pts is None:
    intermediate_pts = [pointA, pointB]

# Validation utilisateur pour enregistrer ou non dans la mémoire
response = TaskDialog.Show(
    "Validation",
    "Voulez-vous enregistrer ce trajet ?",
    TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.No)

if response == TaskDialogResult.Yes:
    new_entry = {
        "d_depart_mur":  d_depart,
        "d_mur_arrivee": d_arrivee,
        "mur_dimensions": dims_mur,
        "path": [[pt.X, pt.Y, pt.Z] for pt in intermediate_pts],
    }
    save_to_memory(MEMORY_FILE, new_entry)
    TaskDialog.Show("Info", "Trajet enregistré.")
else:
    TaskDialog.Show("Info", "Trajet non enregistré.")

# ===========================================================================
# FIN DU SCRIPT
# ===========================================================================